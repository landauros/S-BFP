<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Audio Stability Test</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: #f8fafc;
        color: #1e293b;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      #runBtn {
        padding: 10px 20px;
        font-size: 14px;
        border-radius: 8px;
        border: none;
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: white;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(22, 163, 74, 0.35);
        transition: all 0.2s ease;
      }
      #runBtn:disabled {
        background: #94a3b8;
        cursor: not-allowed;
        box-shadow: none;
        opacity: 0.75;
      }
      #status {
        font-size: 13px;
        padding: 6px 12px;
        border-radius: 9999px;
        background: #e2e8f0;
        color: #1e293b;
      }
      #status.success {
        background: #dcfce7;
        color: #166534;
      }
      #status.error {
        background: #fee2e2;
        color: #b91c1c;
      }
      #hashDisplay {
        font-family: monospace;
        background: #0f172a;
        color: #f8fafc;
        padding: 10px 14px;
        border-radius: 6px;
        letter-spacing: 0.04em;
        overflow-x: auto;
      }
      #results {
        background: white;
        border-radius: 12px;
        border: 1px solid #e2e8f0;
        padding: 16px;
        max-height: 320px;
        overflow-y: auto;
        box-shadow: 0 4px 16px rgba(15, 23, 42, 0.08);
      }
      .result-entry {
        padding: 8px 12px;
        border-radius: 8px;
        margin-bottom: 8px;
        background: #f1f5f9;
        font-family: monospace;
      }
      .result-entry.stable {
        background: #dcfce7;
        color: #166534;
      }
      .result-entry.unstable {
        background: #fee2e2;
        color: #b91c1c;
      }
      .summary {
        font-weight: 600;
      }
    </style>
  </head>
  <body>
      <div class="container">
        <div class="toolbar">
          <button id="runBtn">Run Audio Stability Test</button>
          <span id="status" class="info">Idle</span>
        </div>
        <div id="hashDisplay">Current Hash: Not generated</div>
        <div id="results"></div>
      </div>

    <script type="module">
      import { getSeedString } from "/webgl/preliminary_fingerprint.js";

      const TEST_RUNS = 1;
      const SNIPPET_COUNT = 9;
      const SAMPLE_RATE = 44100;
      const SNIPPET_DURATION_MS = 100;
      const OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;

      const queryParams = new URLSearchParams(window.location.search);
      const autoStart = queryParams.get("autostart") === "1";

      const parentOrigin = window.location.origin;
      const runBtn = document.getElementById("runBtn");
      const statusEl = document.getElementById("status");
      const hashDisplay = document.getElementById("hashDisplay");
      const resultsContainer = document.getElementById("results");
      const currentUser = localStorage.getItem("currentUser");
      let isRunning = false;

      function notifyParent(type, payload = {}) {
        if (!autoStart) return;
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ source: "audio", type, payload }, parentOrigin);
        }
      }

      function formatHash(hash, previewLength = 24) {
        if (!hash) return "N/A";
        return hash.length > previewLength ? `${hash.slice(0, previewLength)}...` : hash;
      }

      function updateStatus(message, tone = "info") {
        statusEl.textContent = message;
        statusEl.className = tone === "success" ? "success" : tone === "error" ? "error" : "info";
      }

      function renderHash(hash) {
        hashDisplay.textContent = `Current Hash: ${hash}`;
      }

      function appendResult(iteration, hash, matchesBaseline) {
        const entry = document.createElement("div");
        entry.className = `result-entry ${matchesBaseline ? "stable" : "unstable"}`;
        entry.textContent = `Run ${iteration}: ${hash} ${matchesBaseline ? "(stable)" : "(changed)"}`;
        resultsContainer.appendChild(entry);
      }

      function appendSummary(allStable, uniqueHashes, totalRuns) {
        const summary = document.createElement("div");
        summary.className = "summary result-entry";
        summary.textContent = allStable
          ? `All ${totalRuns} hashes matched the baseline.`
          : `Hash differences detected: unique hashes are ${uniqueHashes.join(", ")}`;
        resultsContainer.appendChild(summary);
      }

      function displayError(message, target = resultsContainer, anchor = null) {
        const entry = document.createElement("div");
        entry.className = "result-entry unstable";
        entry.textContent = message;
        if (anchor && anchor.parentElement === target) {
          target.insertBefore(entry, anchor);
        } else {
          target.appendChild(entry);
        }
      }

      async function fetchAudioConfig(seed) {
        const url = `/audio/get_snippets_config/${seed}/${SNIPPET_DURATION_MS}/${SAMPLE_RATE}/${SNIPPET_COUNT}/20/80/200/2000`;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch audio config: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();
        if (!Array.isArray(data.frequencies) || !Array.isArray(data.gaps)) {
          throw new Error("Audio config missing required fields");
        }
        return data;
      }

      function float32ToInt16(samples) {
        const buffer = new Int16Array(samples.length);
        for (let i = 0; i < samples.length; i++) {
          const clamped = Math.max(-1, Math.min(1, samples[i]));
          buffer[i] = clamped < 0 ? Math.round(clamped * 0x8000) : Math.round(clamped * 0x7fff);
        }
        return buffer;
      }

      function bufferToHex(buffer) {
        const bytes = new Uint8Array(buffer);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += bytes[i].toString(16).padStart(2, "0");
        }
        return hex;
      }

      async function hashSamples(int16Samples) {
        if (int16Samples.length === 0) {
          return "0".repeat(64);
        }
        const digest = await crypto.subtle.digest("SHA-256", int16Samples);
        return bufferToHex(digest);
      }

      async function renderAudioFingerprint(config) {
        if (!OfflineContext) {
          throw new Error("OfflineAudioContext not supported in this environment");
        }

        const frequencies = config.frequencies || [];
        const gaps = config.gaps || [];
        const snippetDurationMs = config.durationMs ?? SNIPPET_DURATION_MS;
        const sampleRate = config.sampleRate ?? SAMPLE_RATE;
        const snippetDurationSec = snippetDurationMs / 1000;

        let totalDurationSec = snippetDurationSec * frequencies.length;
        for (const gap of gaps) {
          totalDurationSec += gap / 1000;
        }
        const totalFrames = Math.max(1, Math.ceil(totalDurationSec * sampleRate) + sampleRate);
        const context = new OfflineContext(1, totalFrames, sampleRate);

        let cursor = 0;
        frequencies.forEach((freq, index) => {
          const osc = context.createOscillator();
          osc.type = "sine";
          osc.frequency.setValueAtTime(freq, cursor);

          const gain = context.createGain();
          const attack = Math.min(0.01, snippetDurationSec / 10);
          const release = Math.min(0.02, snippetDurationSec / 5);
          const sustainStart = cursor + attack;
          const sustainEnd = cursor + Math.max(0, snippetDurationSec - release);

          gain.gain.setValueAtTime(0, cursor);
          gain.gain.linearRampToValueAtTime(0.6, sustainStart);
          gain.gain.setValueAtTime(0.6, sustainEnd);
          gain.gain.linearRampToValueAtTime(0, cursor + snippetDurationSec);

          osc.connect(gain).connect(context.destination);
          osc.start(cursor);
          osc.stop(cursor + snippetDurationSec);

          cursor += snippetDurationSec;
          if (index < gaps.length) {
            cursor += gaps[index] / 1000;
          }
        });

        const buffer = await context.startRendering();
        const expectedFrames = Math.min(Math.floor(totalDurationSec * sampleRate), buffer.length);
        const channelData = buffer.getChannelData(0).slice(0, Math.max(1, expectedFrames));
        const int16Samples = float32ToInt16(channelData);

        const waveformHash = await hashSamples(int16Samples);
        const snippetFrames = Math.max(1, Math.floor(snippetDurationSec * sampleRate));
        let offset = 0;
        const segmentHashes = [];
        for (let i = 0; i < frequencies.length; i++) {
          const snippet = int16Samples.subarray(offset, offset + snippetFrames);
          segmentHashes.push(await hashSamples(snippet));
          offset += snippetFrames;
          const gapFrames = i < gaps.length ? Math.floor((gaps[i] / 1000) * sampleRate) : 0;
          offset += gapFrames;
        }

        return {
          waveformHash,
          segmentHashes,
          audioConfig: {
            sampleRate,
            snippetDurationMs,
            frequencies,
            gaps,
          },
        };
      }

      async function runSingleIteration(iteration, seed, config) {
        const fingerprint = await renderAudioFingerprint(config);
        const waveformHash = fingerprint.waveformHash;
        return {
          iteration,
          hash: waveformHash,
          waveformHash,
          segmentHashes: fingerprint.segmentHashes,
          audioConfig: fingerprint.audioConfig,
        };
      }

      async function persistAudioStability({ seed, baseline, runs, uniqueHashes, allStable }) {
        if (!currentUser) {
          const message = "No signed-in user detected; unable to save stability record.";
          displayError(message);
          return { success: false, message };
        }
        try {
          const payload = {
            username: currentUser,
            seed,
            baselineHash: baseline,
            allStable,
            uniqueHashes,
            testRuns: runs.map((run) => ({
              iteration: run.iteration,
              hash: run.hash,
              waveformHash: run.waveformHash || run.hash,
              matchesBaseline: run.matchesBaseline,
              segmentHashes: run.segmentHashes,
              audioConfig: run.audioConfig,
            })),
            audioConfig: runs[0]?.audioConfig || null,
            timestamp: new Date().toISOString(),
          };

          const response = await fetch("/user/audio_stability", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const raw = await response.text();
          let parsed = null;
          if (raw) {
            try {
              parsed = JSON.parse(raw);
            } catch (err) {
              console.warn("Failed to parse server response:", err);
            }
          }

          if (!response.ok || (parsed && parsed.status === "error")) {
            const errorMessage =
              (parsed && parsed.error) || raw || response.statusText || "Unknown error";
            throw new Error(errorMessage);
          }

          return { success: true, result: parsed };
        } catch (error) {
          const message = `Failed to save stability record: ${error.message}`;
          displayError(message);
          return { success: false, message };
        }
      }

      async function runAudioStabilityTest({ autoReport = false } = {}) {
        if (isRunning) return;
        isRunning = true;
        runBtn.disabled = true;
        resultsContainer.innerHTML = "";
        renderHash("Not generated");
        updateStatus("Starting audio test...");
        notifyParent("testStarted");

        try {
          const seed = await getSeedString();
          const config = await fetchAudioConfig(seed);
          const runs = [];
          let baseline = null;

          for (let i = 0; i < TEST_RUNS; i++) {
            updateStatus(`Running audio generation ${i + 1}/${TEST_RUNS}...`);
            const iteration = await runSingleIteration(i + 1, seed, config);
            const matchesBaseline = baseline === null || iteration.hash === baseline;

            runs.push({
              iteration: iteration.iteration,
              hash: iteration.hash,
              waveformHash: iteration.waveformHash,
              matchesBaseline,
              segmentHashes: iteration.segmentHashes,
              audioConfig: iteration.audioConfig,
            });

            if (baseline === null) {
              baseline = iteration.hash;
            }

            renderHash(iteration.hash);
            appendResult(i + 1, iteration.hash, matchesBaseline);
          }

          const hashes = runs.map((run) => run.hash);
          const uniqueHashes = [...new Set(hashes)];
          const allStable = uniqueHashes.length === 1;
          appendSummary(allStable, uniqueHashes, runs.length);

          const persistResult = await persistAudioStability({
            seed,
            baseline,
            runs,
            uniqueHashes,
            allStable,
          });

          if (!persistResult || persistResult.success === false) {
            const message = persistResult?.message || "Failed to save audio test results";
            updateStatus(message, "error");
            notifyParent("testError", { message });
            return;
          }

          const serverResult = persistResult.result || {};
          const mismatchRuns = hashes
            .map((hash, index) => (hash === baseline ? null : index + 1))
            .filter((value) => value !== null);
          const payloadMismatchRuns = Array.isArray(serverResult.mismatchRuns)
            ? serverResult.mismatchRuns
            : mismatchRuns;
          const serverAllStable =
            typeof serverResult.allStable === "boolean"
              ? serverResult.allStable
              : allStable;
          const alertMessage =
            serverResult.alertMessage ||
            (allStable
              ? `Audio stable: all ${hashes.length} hashes matched the baseline.`
              : `Audio inconsistency detected: runs ${mismatchRuns.join(", ")} deviated.`);

          updateStatus(alertMessage, serverAllStable ? "success" : "error");
          notifyParent("testComplete", {
            baselineHash: serverResult.baselineHash || baseline,
            allStable,
            uniqueHashes,
            totalRuns: hashes.length,
            mismatchRuns: payloadMismatchRuns,
            serverAllStable,
            alertMessage,
          });
        } catch (error) {
          const message = `Audio test failed: ${error.message}`;
          displayError(message);
          updateStatus(message, "error");
          notifyParent("testError", { message: error.message || message });
        } finally {
          isRunning = false;
          if (!autoReport) {
            runBtn.disabled = false;
          }
        }
      }

      runBtn.addEventListener("click", () => runAudioStabilityTest({ autoReport: false }));

      if (autoStart) {
        runBtn.style.display = "none";
        setTimeout(() => runAudioStabilityTest({ autoReport: true }), 300);
      }
    </script>
  </body>
</html>
